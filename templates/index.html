<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Real-Time Emotion Detection</title>
    <link rel="stylesheet" href="{{ url_for('static', filename='style.css') }}">
    <style>
        #video, #overlay { border-radius: 0.5em; }
        #result { font-size: 1.25em; margin: 1em auto; text-align: center; }
        #container { display: flex; flex-direction: column; align-items: center; }
        #overlay {
            position: absolute;
            z-index: 10;
            top: 0;
            left: 0;
        }
        #video-container {
            position: relative;
            display: inline-block;
        }
    </style>
</head>
<body>
    <div id="container">
        <h1>ðŸ˜Š Real-Time Emotion Detection</h1>
        <div id="video-container">
            <video id="video" width="480" height="360" autoplay muted playsinline></video>
            <canvas id="overlay" width="480" height="360"></canvas>
        </div>
        <div id="result"></div>
    </div>
    <script>
        const video = document.getElementById('video');
        const overlay = document.getElementById('overlay');
        const resultDiv = document.getElementById('result');
        const ctx = overlay.getContext('2d');

        // Ask for webcam
        navigator.mediaDevices.getUserMedia({ video: true })
            .then(stream => { video.srcObject = stream; })
            .catch(err => { alert('Webcam access denied.'); });

        // Helper: draw all faces/bboxes/labels from backend results
        function drawFaces(faces) {
            ctx.clearRect(0, 0, overlay.width, overlay.height);
            if (!faces || faces.length === 0) return;

            faces.forEach(face => {
                // Draw bounding box
                ctx.strokeStyle = "#ffd76d";
                ctx.lineWidth = 3;
                ctx.strokeRect(face.box[0], face.box[1], face.box[2], face.box[3]);

                // Draw label background
                ctx.fillStyle = "rgba(0,0,0,0.5)";
                ctx.fillRect(face.box[0], face.box[1] - 34, ctx.measureText(face.emotion).width + 36, 34);

                // Draw label text
                ctx.font = "24px Arial";
                ctx.fillStyle = "#ffd76d";
                ctx.fillText(face.emotion, face.box[0] + 10, face.box[1] - 10);
            });
        }

        // Capture/send webcam frames
        video.addEventListener('play', () => {
            setInterval(() => {
                ctx.drawImage(video, 0, 0, overlay.width, overlay.height);
                overlay.toBlob(blob => {
                    const formData = new FormData();
                    formData.append('frame', blob, 'frame.png');

                    fetch('/predict', {
                        method: 'POST',
                        body: formData
                    })
                    .then(res => res.json())
                    .then(data => {
                        drawFaces(data.faces);
                        if (data.faces && data.faces.length > 0) {
                            resultDiv.innerHTML = data.faces.map(
                                f => `Face at (${f.box[0]},${f.box[1]}): <b>${f.emotion}</b>`
                            ).join('<br>');
                        } else {
                            resultDiv.innerHTML = "No Face Detected";
                        }
                    });
                }, 'image/png');
            }, 500); // every 0.5s
        });
    </script>
</body>
</html>
